//! # automatically generated
//! This module has been automatically generated by botfair
//! from the Betfair APING documentation at
//! https://docs.developer.betfair.com
//!
//! Any documentation here has been generated directly from the API
//! docs.

#![allow(non_snake_case)]
use crate::generated_requests::*;
use crate::generated_types::*;
use crate::json_rpc::RpcRequest;
use crate::result::Result;
use chrono::{DateTime, Utc};
impl crate::client::BFClient {
    /// Returns a list of Event Types (i.e. Sports) associated with the markets selected by the MarketFilter.
    #[allow(dead_code)]
    pub fn listEventTypes(
        &self,
        filter: MarketFilter,
        locale: Option<String>,
    ) -> Result<Vec<EventTypeResult>> {
        let req: listEventTypesRequest =
            listEventTypesRequest { filter, locale };
        let rpc_request: RpcRequest<listEventTypesRequest> =
            RpcRequest::new("SportsAPING/v1.0/listEventTypes".to_owned(), req);
        self.req(rpc_request).map(|x| x.into_inner())?
    }
    /// Returns a list of Competitions (i.e., World Cup 2013) associated with the markets selected by the MarketFilter. Currently only Football markets have an associated competition.
    #[allow(dead_code)]
    pub fn listCompetitions(
        &self,
        filter: MarketFilter,
        locale: Option<String>,
    ) -> Result<Vec<CompetitionResult>> {
        let req: listCompetitionsRequest =
            listCompetitionsRequest { filter, locale };
        let rpc_request: RpcRequest<listCompetitionsRequest> = RpcRequest::new(
            "SportsAPING/v1.0/listCompetitions".to_owned(),
            req,
        );
        self.req(rpc_request).map(|x| x.into_inner())?
    }
    /// Returns a list of time ranges in the granularity specified in the request (i.e. 3PM to 4PM, Aug 14th to Aug 15th) associated with the markets selected by the MarketFilter.
    #[allow(dead_code)]
    pub fn listTimeRanges(
        &self,
        filter: MarketFilter,
        granularity: TimeGranularity,
    ) -> Result<Vec<TimeRangeResult>> {
        let req: listTimeRangesRequest = listTimeRangesRequest {
            filter,
            granularity,
        };
        let rpc_request: RpcRequest<listTimeRangesRequest> =
            RpcRequest::new("SportsAPING/v1.0/listTimeRanges".to_owned(), req);
        self.req(rpc_request).map(|x| x.into_inner())?
    }
    /// Returns a list of Events (i.e, Reading vs. Man United) associated with the markets selected by the MarketFilter.
    #[allow(dead_code)]
    pub fn listEvents(
        &self,
        filter: MarketFilter,
        locale: Option<String>,
    ) -> Result<Vec<EventResult>> {
        let req: listEventsRequest = listEventsRequest { filter, locale };
        let rpc_request: RpcRequest<listEventsRequest> =
            RpcRequest::new("SportsAPING/v1.0/listEvents".to_owned(), req);
        self.req(rpc_request).map(|x| x.into_inner())?
    }
    /// Returns a list of market types (i.e. MATCH_ODDS, NEXT_GOAL) associated with the markets selected by the MarketFilter. The market types are always the same, regardless of locale.
    #[allow(dead_code)]
    pub fn listMarketTypes(
        &self,
        filter: MarketFilter,
        locale: Option<String>,
    ) -> Result<Vec<MarketTypeResult>> {
        let req: listMarketTypesRequest =
            listMarketTypesRequest { filter, locale };
        let rpc_request: RpcRequest<listMarketTypesRequest> = RpcRequest::new(
            "SportsAPING/v1.0/listMarketTypes".to_owned(),
            req,
        );
        self.req(rpc_request).map(|x| x.into_inner())?
    }
    /// Returns a list of Countries associated with the markets selected by the MarketFilter.
    #[allow(dead_code)]
    pub fn listCountries(
        &self,
        filter: MarketFilter,
        locale: Option<String>,
    ) -> Result<Vec<CountryCodeResult>> {
        let req: listCountriesRequest =
            listCountriesRequest { filter, locale };
        let rpc_request: RpcRequest<listCountriesRequest> =
            RpcRequest::new("SportsAPING/v1.0/listCountries".to_owned(), req);
        self.req(rpc_request).map(|x| x.into_inner())?
    }
    /// Returns a list of Venues (i.e. Cheltenham, Ascot) associated with the markets selected by the MarketFilter. Currently, only Horse Racing markets are associated with a Venue.
    #[allow(dead_code)]
    pub fn listVenues(
        &self,
        filter: MarketFilter,
        locale: Option<String>,
    ) -> Result<Vec<VenueResult>> {
        let req: listVenuesRequest = listVenuesRequest { filter, locale };
        let rpc_request: RpcRequest<listVenuesRequest> =
            RpcRequest::new("SportsAPING/v1.0/listVenues".to_owned(), req);
        self.req(rpc_request).map(|x| x.into_inner())?
    }
    /// Returns a list of information about markets that does not change (or changes very rarely). You use listMarketCatalogue to retrieve the name of the market, the names of selections and other information about markets.
    #[allow(dead_code)]
    pub fn listMarketCatalogue(
        &self,
        filter: MarketFilter,
        marketProjection: Option<Vec<MarketProjection>>,
        sort: Option<MarketSort>,
        maxResults: i32,
        locale: Option<String>,
    ) -> Result<Vec<MarketCatalogue>> {
        let req: listMarketCatalogueRequest = listMarketCatalogueRequest {
            filter,
            marketProjection,
            sort,
            maxResults,
            locale,
        };
        let rpc_request: RpcRequest<listMarketCatalogueRequest> =
            RpcRequest::new(
                "SportsAPING/v1.0/listMarketCatalogue".to_owned(),
                req,
            );
        self.req(rpc_request).map(|x| x.into_inner())?
    }
    /// Returns a list of dynamic data about markets. Dynamic data includes prices, the status of the market, the status of selections, the traded volume, and the status of any orders you have placed in the market.
    #[allow(dead_code)]
    pub fn listMarketBook(
        &self,
        marketIds: Vec<MarketId>,
        priceProjection: Option<PriceProjection>,
        orderProjection: Option<OrderProjection>,
        matchProjection: Option<MatchProjection>,
        includeOverallPosition: Option<bool>,
        partitionMatchedByStrategyRef: Option<bool>,
        customerStrategyRefs: Option<Vec<String>>,
        currencyCode: Option<String>,
        locale: Option<String>,
        matchedSince: Option<DateTime<Utc>>,
        betIds: Option<Vec<BetId>>,
    ) -> Result<Vec<MarketBook>> {
        let req: listMarketBookRequest = listMarketBookRequest {
            marketIds,
            priceProjection,
            orderProjection,
            matchProjection,
            includeOverallPosition,
            partitionMatchedByStrategyRef,
            customerStrategyRefs,
            currencyCode,
            locale,
            matchedSince,
            betIds,
        };
        let rpc_request: RpcRequest<listMarketBookRequest> =
            RpcRequest::new("SportsAPING/v1.0/listMarketBook".to_owned(), req);
        self.req(rpc_request).map(|x| x.into_inner())?
    }
    /// Returns a list of dynamic data about a market and a specified runner. Dynamic data includes prices, the status of the market, the status of selections, the traded volume, and the status of any orders you have placed in the market.
    #[allow(dead_code)]
    pub fn listRunnerBook(
        &self,
        marketId: MarketId,
        selectionId: SelectionId,
        handicap: Option<f64>,
        priceProjection: Option<PriceProjection>,
        orderProjection: Option<OrderProjection>,
        matchProjection: Option<MatchProjection>,
        includeOverallPosition: Option<bool>,
        partitionMatchedByStrategyRef: Option<bool>,
        customerStrategyRefs: Option<Vec<String>>,
        currencyCode: Option<String>,
        locale: Option<String>,
        matchedSince: Option<DateTime<Utc>>,
        betIds: Option<Vec<BetId>>,
    ) -> Result<Vec<MarketBook>> {
        let req: listRunnerBookRequest = listRunnerBookRequest {
            marketId,
            selectionId,
            handicap,
            priceProjection,
            orderProjection,
            matchProjection,
            includeOverallPosition,
            partitionMatchedByStrategyRef,
            customerStrategyRefs,
            currencyCode,
            locale,
            matchedSince,
            betIds,
        };
        let rpc_request: RpcRequest<listRunnerBookRequest> =
            RpcRequest::new("SportsAPING/v1.0/listRunnerBook".to_owned(), req);
        self.req(rpc_request).map(|x| x.into_inner())?
    }
    /// Returns a list of your current orders. Optionally you can filter and sort your current orders using the various parameters, setting none of the parameters will return all of your current orders, up to a maximum of 1000 bets, ordered BY_BET and sorted EARLIEST_TO_LATEST. To retrieve more than 1000 orders, you need to make use of the fromRecord and recordCount parameters.
    #[allow(dead_code)]
    pub fn listCurrentOrders(
        &self,
        betIds: Option<Vec<BetId>>,
        marketIds: Option<Vec<MarketId>>,
        orderProjection: Option<OrderProjection>,
        customerOrderRefs: Option<Vec<CustomerOrderRef>>,
        customerStrategyRefs: Option<Vec<CustomerStrategyRef>>,
        placedDateRange: Option<TimeRange>,
        dateRange: Option<TimeRange>,
        orderBy: Option<OrderBy>,
        sortDir: Option<SortDir>,
        fromRecord: Option<i32>,
        recordCount: Option<i32>,
    ) -> Result<CurrentOrderSummaryReport> {
        let req: listCurrentOrdersRequest = listCurrentOrdersRequest {
            betIds,
            marketIds,
            orderProjection,
            customerOrderRefs,
            customerStrategyRefs,
            placedDateRange,
            dateRange,
            orderBy,
            sortDir,
            fromRecord,
            recordCount,
        };
        let rpc_request: RpcRequest<listCurrentOrdersRequest> =
            RpcRequest::new(
                "SportsAPING/v1.0/listCurrentOrders".to_owned(),
                req,
            );
        self.req(rpc_request).map(|x| x.into_inner())?
    }
    /// Returns a List of bets based on the bet status, ordered by settled date
    #[allow(dead_code)]
    pub fn listClearedOrders(
        &self,
        betStatus: BetStatus,
        eventTypeIds: Option<Vec<EventTypeId>>,
        eventIds: Option<Vec<EventId>>,
        marketIds: Option<Vec<MarketId>>,
        runnerIds: Option<Vec<RunnerId>>,
        betIds: Option<Vec<BetId>>,
        customerOrderRefs: Option<Vec<CustomerOrderRef>>,
        customerStrategyRefs: Option<Vec<CustomerStrategyRef>>,
        side: Option<Side>,
        settledDateRange: Option<TimeRange>,
        groupBy: Option<GroupBy>,
        includeItemDescription: Option<bool>,
        locale: Option<String>,
        fromRecord: Option<i32>,
        recordCount: Option<i32>,
    ) -> Result<ClearedOrderSummaryReport> {
        let req: listClearedOrdersRequest = listClearedOrdersRequest {
            betStatus,
            eventTypeIds,
            eventIds,
            marketIds,
            runnerIds,
            betIds,
            customerOrderRefs,
            customerStrategyRefs,
            side,
            settledDateRange,
            groupBy,
            includeItemDescription,
            locale,
            fromRecord,
            recordCount,
        };
        let rpc_request: RpcRequest<listClearedOrdersRequest> =
            RpcRequest::new(
                "SportsAPING/v1.0/listClearedOrders".to_owned(),
                req,
            );
        self.req(rpc_request).map(|x| x.into_inner())?
    }
    /// Place new orders into market. LIMIT orders below the minimum bet size are allowed if there is an unmatched bet at the same price in the market. This operation is atomic in that all orders will be placed or none will be placed.
    #[allow(dead_code)]
    pub fn placeOrders(
        &self,
        marketId: MarketId,
        instructions: Vec<PlaceInstruction>,
        customerRef: Option<String>,
        marketVersion: Option<MarketVersion>,
        customerStrategyRef: Option<String>,
        r#async: Option<bool>,
    ) -> Result<PlaceExecutionReport> {
        let req: placeOrdersRequest = placeOrdersRequest {
            marketId,
            instructions,
            customerRef,
            marketVersion,
            customerStrategyRef,
            r#async,
        };
        let rpc_request: RpcRequest<placeOrdersRequest> =
            RpcRequest::new("SportsAPING/v1.0/placeOrders".to_owned(), req);
        self.req(rpc_request).map(|x| x.into_inner())?
    }
    /// Cancel all bets OR cancel all bets on a market OR fully or partially cancel particular orders on a market. Only LIMIT orders an be cancelled or partially cancelled once placed.
    #[allow(dead_code)]
    pub fn cancelOrders(
        &self,
        marketId: Option<MarketId>,
        instructions: Option<Vec<CancelInstruction>>,
        customerRef: Option<String>,
    ) -> Result<CancelExecutionReport> {
        let req: cancelOrdersRequest = cancelOrdersRequest {
            marketId,
            instructions,
            customerRef,
        };
        let rpc_request: RpcRequest<cancelOrdersRequest> =
            RpcRequest::new("SportsAPING/v1.0/cancelOrders".to_owned(), req);
        self.req(rpc_request).map(|x| x.into_inner())?
    }
    /// This operation is logically a bulk cancel followed by a bulk place. The cancel is completed first then the new orders are placed. The new orders will be placed atomically in that they will all be placed or none will be placed. In the case where the new orders cannot be placed the cancellations will not be rolled back. See ReplaceInstruction.
    #[allow(dead_code)]
    pub fn replaceOrders(
        &self,
        marketId: MarketId,
        instructions: Vec<ReplaceInstruction>,
        customerRef: Option<String>,
        marketVersion: Option<MarketVersion>,
        r#async: Option<bool>,
    ) -> Result<ReplaceExecutionReport> {
        let req: replaceOrdersRequest = replaceOrdersRequest {
            marketId,
            instructions,
            customerRef,
            marketVersion,
            r#async,
        };
        let rpc_request: RpcRequest<replaceOrdersRequest> =
            RpcRequest::new("SportsAPING/v1.0/replaceOrders".to_owned(), req);
        self.req(rpc_request).map(|x| x.into_inner())?
    }
    /// Update non-exposure changing fields
    #[allow(dead_code)]
    pub fn updateOrders(
        &self,
        marketId: MarketId,
        instructions: Vec<UpdateInstruction>,
        customerRef: Option<String>,
    ) -> Result<UpdateExecutionReport> {
        let req: updateOrdersRequest = updateOrdersRequest {
            marketId,
            instructions,
            customerRef,
        };
        let rpc_request: RpcRequest<updateOrdersRequest> =
            RpcRequest::new("SportsAPING/v1.0/updateOrders".to_owned(), req);
        self.req(rpc_request).map(|x| x.into_inner())?
    }
    /// Retrieve profit and loss for a given list of markets. The values are calculated using matched bets and optionally settled bets. Only odds markets are implemented, markets of other types are silently ignored.
    #[allow(dead_code)]
    pub fn listMarketProfitAndLoss(
        &self,
        marketIds: Vec<MarketId>,
        includeSettledBets: Option<bool>,
        includeBspBets: Option<bool>,
        netOfCommission: Option<bool>,
    ) -> Result<Vec<MarketProfitAndLoss>> {
        let req: listMarketProfitAndLossRequest =
            listMarketProfitAndLossRequest {
                marketIds,
                includeSettledBets,
                includeBspBets,
                netOfCommission,
            };
        let rpc_request: RpcRequest<listMarketProfitAndLossRequest> =
            RpcRequest::new(
                "SportsAPING/v1.0/listMarketProfitAndLoss".to_owned(),
                req,
            );
        self.req(rpc_request).map(|x| x.into_inner())?
    }
    /// Create/update default exposure limit for market groups of given type. New value and breach action will be immediately applied to existing instances of this type (unless overridden using setExposureLimitForMarketGroup). If default values are overridden for market groups (using setExposureLimitForMarketGroup), overrides will NOT be touched. In order to clear this limit "removeDefaultExposureLimitForMarketGroups" operation should be used. It's not allowed to set default limit to an empty limit (see type ExposureLimit).
    #[allow(dead_code)]
    pub fn setDefaultExposureLimitForMarketGroups(
        &self,
        marketGroupType: MarketGroupType,
        limit: ExposureLimit,
    ) -> Result<String> {
        let req: setDefaultExposureLimitForMarketGroupsRequest =
            setDefaultExposureLimitForMarketGroupsRequest {
                marketGroupType,
                limit,
            };
        let rpc_request: RpcRequest<
            setDefaultExposureLimitForMarketGroupsRequest,
        > = RpcRequest::new(
            "SportsAPING/v1.0/setDefaultExposureLimitForMarketGroups"
                .to_owned(),
            req,
        );
        self.req(rpc_request).map(|x| x.into_inner())?
    }
    /// Create/update exposure limit for a market group. New limit will be applied immediately (even if a default limit exists for this type). The limit will be deleted upon account action (see deleteMarketGroupExposureLimit) or when no active markets remain under market group. It is possible to "invalidate" default limit for a specific group by using a "empty" limit (see type ExposureLimit). Upon successful execution of the request, the effective limit for this group will be the one set by this request (Properties will NOT be inherited from default limit).
    #[allow(dead_code)]
    pub fn setExposureLimitForMarketGroup(
        &self,
        marketGroup: MarketGroup,
        limit: ExposureLimit,
    ) -> Result<String> {
        let req: setExposureLimitForMarketGroupRequest =
            setExposureLimitForMarketGroupRequest { marketGroup, limit };
        let rpc_request: RpcRequest<setExposureLimitForMarketGroupRequest> =
            RpcRequest::new(
                "SportsAPING/v1.0/setExposureLimitForMarketGroup".to_owned(),
                req,
            );
        self.req(rpc_request).map(|x| x.into_inner())?
    }
    /// Remove default exposure limit for a market group type. This operation will NOT remove/update any market group limits.
    #[allow(dead_code)]
    pub fn removeDefaultExposureLimitForMarketGroups(
        &self,
        marketGroupType: MarketGroupType,
    ) -> Result<String> {
        let req: removeDefaultExposureLimitForMarketGroupsRequest =
            removeDefaultExposureLimitForMarketGroupsRequest {
                marketGroupType,
            };
        let rpc_request: RpcRequest<
            removeDefaultExposureLimitForMarketGroupsRequest,
        > = RpcRequest::new(
            "SportsAPING/v1.0/removeDefaultExposureLimitForMarketGroups"
                .to_owned(),
            req,
        );
        self.req(rpc_request).map(|x| x.into_inner())?
    }
    /// Delete exposure limit for a market group. If a default exposure limit exist for market type, it takes effect immediately.
    #[allow(dead_code)]
    pub fn removeExposureLimitForMarketGroup(
        &self,
        marketGroup: MarketGroup,
    ) -> Result<String> {
        let req: removeExposureLimitForMarketGroupRequest =
            removeExposureLimitForMarketGroupRequest { marketGroup };
        let rpc_request: RpcRequest<removeExposureLimitForMarketGroupRequest> =
            RpcRequest::new(
                "SportsAPING/v1.0/removeExposureLimitForMarketGroup"
                    .to_owned(),
                req,
            );
        self.req(rpc_request).map(|x| x.into_inner())?
    }
    /// Response to this request returns default group limit and group limits grouped by type. If marketGroupTypeFilter is not populated values for all types are returned. The response will always contain the default limit. It is possible to control which groups to return using marketGroupsFilter parameter. If marketGroupsFilter is not set all group limits are returned. If an emtpy list is passed only default limit(s) is returned. When marketGroupTypeFilter and marketGroupsFilter used together, all groups in marketGroupsFilter are required to be of same type (type used in marketGroupTypeFilter).
    #[allow(dead_code)]
    pub fn listExposureLimitsForMarketGroups(
        &self,
        marketGroupTypeFilter: Option<MarketGroupType>,
        marketGroupFilter: Option<Vec<MarketGroup>>,
    ) -> Result<Vec<ExposureLimitsForMarketGroups>> {
        let req: listExposureLimitsForMarketGroupsRequest =
            listExposureLimitsForMarketGroupsRequest {
                marketGroupTypeFilter,
                marketGroupFilter,
            };
        let rpc_request: RpcRequest<listExposureLimitsForMarketGroupsRequest> =
            RpcRequest::new(
                "SportsAPING/v1.0/listExposureLimitsForMarketGroups"
                    .to_owned(),
                req,
            );
        self.req(rpc_request).map(|x| x.into_inner())?
    }
    /// Unblock a market group after it has been blocked due to the breach of a previously set exposure limit.
    #[allow(dead_code)]
    pub fn unblockMarketGroup(
        &self,
        marketGroup: MarketGroup,
    ) -> Result<String> {
        let req: unblockMarketGroupRequest =
            unblockMarketGroupRequest { marketGroup };
        let rpc_request: RpcRequest<unblockMarketGroupRequest> =
            RpcRequest::new(
                "SportsAPING/v1.0/unblockMarketGroup".to_owned(),
                req,
            );
        self.req(rpc_request).map(|x| x.into_inner())?
    }
    /// Retrieves events from exposure reuse enabled events list. To edit this list use addExposureReuseEnabledEvents and removeExposureReuseEnabledEvents operations.
    #[allow(dead_code)]
    pub fn getExposureReuseEnabledEvents(&self) -> Result<Vec<i64>> {
        let rpc_request: RpcRequest<()> = RpcRequest::new(
            "SportsAPING/v1.0/getExposureReuseEnabledEvents".to_owned(),
            (),
        );
        self.req(rpc_request).map(|x| x.into_inner())?
    }
    /// Enables events for exposure reuse by appending them to the current list of events already enabled.
    #[allow(dead_code)]
    pub fn addExposureReuseEnabledEvents(
        &self,
        eventIds: Vec<i64>,
    ) -> Result<String> {
        let req: addExposureReuseEnabledEventsRequest =
            addExposureReuseEnabledEventsRequest { eventIds };
        let rpc_request: RpcRequest<addExposureReuseEnabledEventsRequest> =
            RpcRequest::new(
                "SportsAPING/v1.0/addExposureReuseEnabledEvents".to_owned(),
                req,
            );
        self.req(rpc_request).map(|x| x.into_inner())?
    }
    /// Removes events from exposure reuse enabled events list.
    #[allow(dead_code)]
    pub fn removeExposureReuseEnabledEvents(
        &self,
        eventIds: Vec<i64>,
    ) -> Result<String> {
        let req: removeExposureReuseEnabledEventsRequest =
            removeExposureReuseEnabledEventsRequest { eventIds };
        let rpc_request: RpcRequest<removeExposureReuseEnabledEventsRequest> =
            RpcRequest::new(
                "SportsAPING/v1.0/removeExposureReuseEnabledEvents".to_owned(),
                req,
            );
        self.req(rpc_request).map(|x| x.into_inner())?
    }
}
