//! # automatically generated
//! This module has been automatically generated by botfair
//! from the Betfair APING documentation at
//! https://docs.developer.betfair.com
//!
//! Any documentation here has been generated directly from the API
//! docs.

#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
use crate::generated_types::*;
use chrono::{DateTime, Utc};
use serde::Serialize;
#[derive(Serialize)]
pub struct listEventTypesRequest {
    pub filter: MarketFilter,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub locale: Option<String>,
}
#[derive(Serialize)]
pub struct listCompetitionsRequest {
    pub filter: MarketFilter,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub locale: Option<String>,
}
#[derive(Serialize)]
pub struct listTimeRangesRequest {
    pub filter: MarketFilter,
    pub granularity: TimeGranularity,
}
#[derive(Serialize)]
pub struct listEventsRequest {
    pub filter: MarketFilter,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub locale: Option<String>,
}
#[derive(Serialize)]
pub struct listMarketTypesRequest {
    pub filter: MarketFilter,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub locale: Option<String>,
}
#[derive(Serialize)]
pub struct listCountriesRequest {
    pub filter: MarketFilter,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub locale: Option<String>,
}
#[derive(Serialize)]
pub struct listVenuesRequest {
    pub filter: MarketFilter,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub locale: Option<String>,
}
#[derive(Serialize)]
pub struct listMarketCatalogueRequest {
    pub filter: MarketFilter,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marketProjection: Option<Vec<MarketProjection>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sort: Option<MarketSort>,
    pub maxResults: i32,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub locale: Option<String>,
}
#[derive(Serialize)]
pub struct listMarketBookRequest {
    pub marketIds: Vec<MarketId>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priceProjection: Option<PriceProjection>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub orderProjection: Option<OrderProjection>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub matchProjection: Option<MatchProjection>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub includeOverallPosition: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub partitionMatchedByStrategyRef: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub customerStrategyRefs: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub currencyCode: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub locale: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub matchedSince: Option<DateTime<Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub betIds: Option<Vec<BetId>>,
}
#[derive(Serialize)]
pub struct listRunnerBookRequest {
    pub marketId: MarketId,
    pub selectionId: SelectionId,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub handicap: Option<f64>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub priceProjection: Option<PriceProjection>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub orderProjection: Option<OrderProjection>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub matchProjection: Option<MatchProjection>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub includeOverallPosition: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub partitionMatchedByStrategyRef: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub customerStrategyRefs: Option<Vec<String>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub currencyCode: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub locale: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub matchedSince: Option<DateTime<Utc>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub betIds: Option<Vec<BetId>>,
}
#[derive(Serialize)]
pub struct listCurrentOrdersRequest {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub betIds: Option<Vec<BetId>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marketIds: Option<Vec<MarketId>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub orderProjection: Option<OrderProjection>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub customerOrderRefs: Option<Vec<CustomerOrderRef>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub customerStrategyRefs: Option<Vec<CustomerStrategyRef>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub placedDateRange: Option<TimeRange>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub dateRange: Option<TimeRange>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub orderBy: Option<OrderBy>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub sortDir: Option<SortDir>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fromRecord: Option<i32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recordCount: Option<i32>,
}
#[derive(Serialize)]
pub struct listClearedOrdersRequest {
    pub betStatus: BetStatus,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub eventTypeIds: Option<Vec<EventTypeId>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub eventIds: Option<Vec<EventId>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marketIds: Option<Vec<MarketId>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub runnerIds: Option<Vec<RunnerId>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub betIds: Option<Vec<BetId>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub customerOrderRefs: Option<Vec<CustomerOrderRef>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub customerStrategyRefs: Option<Vec<CustomerStrategyRef>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub side: Option<Side>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub settledDateRange: Option<TimeRange>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub groupBy: Option<GroupBy>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub includeItemDescription: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub locale: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fromRecord: Option<i32>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub recordCount: Option<i32>,
}
#[derive(Serialize)]
pub struct placeOrdersRequest {
    pub marketId: MarketId,
    pub instructions: Vec<PlaceInstruction>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub customerRef: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marketVersion: Option<MarketVersion>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub customerStrategyRef: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub r#async: Option<bool>,
}
#[derive(Serialize)]
pub struct cancelOrdersRequest {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marketId: Option<MarketId>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub instructions: Option<Vec<CancelInstruction>>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub customerRef: Option<String>,
}
#[derive(Serialize)]
pub struct replaceOrdersRequest {
    pub marketId: MarketId,
    pub instructions: Vec<ReplaceInstruction>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub customerRef: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marketVersion: Option<MarketVersion>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub r#async: Option<bool>,
}
#[derive(Serialize)]
pub struct updateOrdersRequest {
    pub marketId: MarketId,
    pub instructions: Vec<UpdateInstruction>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub customerRef: Option<String>,
}
#[derive(Serialize)]
pub struct listMarketProfitAndLossRequest {
    pub marketIds: Vec<MarketId>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub includeSettledBets: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub includeBspBets: Option<bool>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub netOfCommission: Option<bool>,
}
#[derive(Serialize)]
pub struct setDefaultExposureLimitForMarketGroupsRequest {
    pub marketGroupType: MarketGroupType,
    pub limit: ExposureLimit,
}
#[derive(Serialize)]
pub struct setExposureLimitForMarketGroupRequest {
    pub marketGroup: MarketGroup,
    pub limit: ExposureLimit,
}
#[derive(Serialize)]
pub struct removeDefaultExposureLimitForMarketGroupsRequest {
    pub marketGroupType: MarketGroupType,
}
#[derive(Serialize)]
pub struct removeExposureLimitForMarketGroupRequest {
    pub marketGroup: MarketGroup,
}
#[derive(Serialize)]
pub struct listExposureLimitsForMarketGroupsRequest {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marketGroupTypeFilter: Option<MarketGroupType>,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub marketGroupFilter: Option<Vec<MarketGroup>>,
}
#[derive(Serialize)]
pub struct unblockMarketGroupRequest {
    pub marketGroup: MarketGroup,
}
#[derive(Serialize)]
pub struct addExposureReuseEnabledEventsRequest {
    pub eventIds: Vec<i64>,
}
#[derive(Serialize)]
pub struct removeExposureReuseEnabledEventsRequest {
    pub eventIds: Vec<i64>,
}
